name: Veracode Ultimate (Pipeline Scan + SARIF + Fix Universal)

on:
  workflow_dispatch:
    inputs:
      run_fix:
        description: "Run Veracode Fix (batch PR) after scan"
        required: true
        default: "true"
  pull_request:
    branches: [ main, master ]

permissions:
  contents: write
  pull-requests: write
  actions: read
  security-events: write

jobs:
  pipeline_scan_and_sarif:
    runs-on: ubuntu-latest
    outputs:
      has_results: ${{ steps.scan_outputs.outputs.has_results }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure placeholder file exists (SARIF)
        run: |
          mkdir -p .veracode
          cat > .veracode/PIPELINE_SCAN_GLOBAL_FINDINGS.md << 'EOF'
          # Veracode Pipeline Scan – Global Findings Placeholder
          Findings without a resolvable repo file+line are anchored here.
          EOF

      - name: Create source zip (exclude node_modules)
        run: |
          zip -r pipeline-src.zip . -x "**/node_modules/**" -x "**/.git/**"

      - name: Set up Java (Pipeline Scan tool)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Download Pipeline Scan tool
        run: |
          curl -sSLO https://downloads.veracode.com/securityscan/pipeline-scan-LATEST.zip
          unzip -o pipeline-scan-LATEST.zip

      - name: Run Pipeline Scan (ESD enabled, do not fail job on findings)
        id: scan_outputs
        env:
          VERACODE_API_ID: ${{ secrets.VERACODE_API_ID }}
          VERACODE_API_KEY: ${{ secrets.VERACODE_API_KEY }}
        run: |
          set -euo pipefail

          # Pipeline Scan exits non-zero when findings exist. Capture RC but keep going.
          set +e
          java -jar pipeline-scan.jar \
            -vid "${VERACODE_API_ID}" \
            -vkey "${VERACODE_API_KEY}" \
            -f "pipeline-src.zip" \
            -esd true \
            -jf "results.json" \
            -fjf "filtered_results.json"
          RC=$?
          set -e

          echo "Pipeline Scan exit code: $RC"
          ls -lah results.json filtered_results.json || true

          if [ -f results.json ] && [ -f filtered_results.json ]; then
            echo "has_results=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_results=false" >> "$GITHUB_OUTPUT"
            echo "ERROR: Pipeline Scan did not produce results.json / filtered_results.json"
            exit 1
          fi

      - name: Setup Python (SARIF conversion)
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Convert Pipeline JSON -> SARIF
        run: |
          python scripts/pipeline_results_to_sarif.py \
            --input filtered_results.json \
            --output veracode-pipeline.sarif \
            --placeholder-uri .veracode/PIPELINE_SCAN_GLOBAL_FINDINGS.md \
            --output-stats veracode-pipeline-sarif-stats.json

      - name: Upload SARIF to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: veracode-pipeline.sarif
          category: veracode-pipeline
          wait-for-processing: true

      - name: Upload pipeline artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: veracode-pipeline-scan
          path: |
            results.json
            filtered_results.json
            veracode-pipeline.sarif
            veracode-pipeline-sarif-stats.json
            .veracode/PIPELINE_SCAN_GLOBAL_FINDINGS.md

  build_fix_matrix:
    needs: pipeline_scan_and_sarif
    if: needs.pipeline_scan_and_sarif.outputs.has_results == 'true'
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.mk.outputs.matrix }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download scan outputs
        uses: actions/download-artifact@v4
        with:
          name: veracode-pipeline-scan
          path: pipeline_out

      - name: Setup Python (matrix builder)
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Build Fix matrix from filtered_results.json (languages + batch-supported CWEs)
        id: mk
        run: |
          set -euo pipefail

          python - << 'PY' > matrix.json
          import json, os
          from collections import Counter

          # GitHub Action supported languages:
          # java, csharp, javascript, python, kotlin, scala, php, go   [oai_citation:3‡Veracode Docs](https://docs.veracode.com/r/Veracode_Fix_GitHub_Action?utm_source=chatgpt.com)
          SUPPORTED = {"java","csharp","javascript","python","kotlin","scala","php","go"}

          # Batch-supported CWEs per language from "About Veracode Fix" tables.  [oai_citation:4‡Veracode Docs](https://docs.veracode.com/r/About_Veracode_Fix)
          # IMPORTANT: We include only CWEs with Batch fix support, because this workflow uses fixType: batch.
          CWES_BATCH = {
            "csharp":     "80,89,117,209,316,331,352,404,611",
            "go":         "73,78,117",
            "java":       "80,89,113,117,159,209,331,404,597,611",
            "javascript": "80,89,113,117,209,352,601,611,614",
            "kotlin":     "80,89,113,117,331,404",
            "php":        "80,89,117",
            "python":     "78,80,89,295,331,757",
            "scala":      "78,80,117,611",
          }

          EXT_TO_LANG = {
            ".java": "java",
            ".kt": "kotlin",
            ".scala": "scala",
            ".cs": "csharp",
            ".js": "javascript",
            ".ts": "javascript",
            ".jsx": "javascript",
            ".tsx": "javascript",
            ".py": "python",
            ".php": "php",
            ".go": "go",
          }

          def norm(p: str) -> str:
            return (p or "").replace("\\","/").strip().lstrip("./").lstrip("/")

          def src_path(finding: dict):
            files = finding.get("files") or {}
            src = files.get("source_file") or {}
            p = src.get("file") or src.get("upload_file")
            return norm(str(p)) if p else None

          def lang_from_path(p: str):
            pl = p.lower()
            for ext, lang in EXT_TO_LANG.items():
              if pl.endswith(ext):
                return lang
            return None

          with open("pipeline_out/filtered_results.json","r",encoding="utf-8") as f:
            data = json.load(f)

          findings = data.get("findings", []) if isinstance(data, dict) else []

          lang_paths = {k: [] for k in SUPPORTED}
          for x in findings:
            if not isinstance(x, dict):
              continue
            p = src_path(x)
            if not p:
              continue
            lang = lang_from_path(p)
            if lang in SUPPORTED:
              lang_paths[lang].append(p)

          include = []

          # Helper: choose a best top-level root for JS/Py/etc based on most common first segment
          def choose_root(paths, candidates):
            cnt = Counter()
            for p in paths:
              parts = p.split("/")
              if parts and parts[0] in candidates:
                cnt[parts[0]] += 1
            if cnt:
              return cnt.most_common(1)[0][0]
            # fallback: pick first existing directory among candidates
            for d in candidates:
              if os.path.isdir(d):
                return d
            return "src"

          JS_CANDIDATES = ["src","routes","frontend","lib","app","server","client","packages"]
          PY_CANDIDATES = ["src","app","server","lib"]

          for lang, paths in lang_paths.items():
            if not paths:
              continue
            cwe = CWES_BATCH.get(lang)
            if not cwe:
              # if not defined, skip; keeps workflow stable
              continue

            sbp1 = sbp2 = sbp3 = ""

            if lang in ("java","kotlin","scala"):
              sbp1 = "com/:src/main/java/com/"
              sbp2 = "WEB-INF:src/main/webapp/WEB-INF"
              sbp3 = ""
            elif lang == "javascript":
              root = choose_root(paths, JS_CANDIDATES)
              sbp1 = f"{root}/:{root}/"
              sbp2 = ""
              sbp3 = ""
            elif lang == "python":
              root = choose_root(paths, PY_CANDIDATES)
              sbp1 = f"{root}/:{root}/"
              sbp2 = ""
              sbp3 = ""
            else:
              # go/php/csharp: try "src/" identity mapping
              sbp1 = "src/:src/"
              sbp2 = ""
              sbp3 = ""

            include.append({
              "language": lang,
              "cwe": cwe,
              "sbp1": sbp1,
              "sbp2": sbp2,
              "sbp3": sbp3
            })

          out = {"include": include}
          print(json.dumps(out))
          PY

          MATRIX="$(cat matrix.json)"
          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
          echo "Fix matrix: $MATRIX"

  veracode_fix_universal:
    needs: [pipeline_scan_and_sarif, build_fix_matrix]
    if: (github.event_name == 'pull_request' || inputs.run_fix == 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 120
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: ${{ fromJson(needs.build_fix_matrix.outputs.matrix) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download scan outputs
        uses: actions/download-artifact@v4
        with:
          name: veracode-pipeline-scan
          path: pipeline_out

      - name: Verify Fix input exists
        run: |
          set -euo pipefail
          test -f pipeline_out/filtered_results.json

      - name: Run Veracode Fix (Batch → PR) — language=${{ matrix.language }}
        continue-on-error: true
        uses: Veracode/veracode-fix@v1.0.4
        with:
          vid: ${{ secrets.VID }}
          vkey: ${{ secrets.VKEY }}
          inputFile: pipeline_out/filtered_results.json
          language: ${{ matrix.language }}
          cwe: ${{ matrix.cwe }}
          fixType: batch
          files: all
          prComment: true
          createPR: true
          source_base_path_1: ${{ matrix.sbp1 }}
          source_base_path_2: ${{ matrix.sbp2 }}
          source_base_path_3: ${{ matrix.sbp3 }}
