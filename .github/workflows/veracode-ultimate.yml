name: Veracode Ultimate (Pipeline Scan + SARIF + Batch Fix)

on:
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      run_fix:
        description: "Run Veracode Fix batch after scan (creates PR when not in PR event)"
        required: true
        default: "true"
      fix_severities:
        description: "Severities Fix should attempt (comma-separated): 5=VERY_HIGH,4=HIGH,3=MEDIUM,2=LOW,1=VERY_LOW,0=INFO"
        required: true
        default: "5,4"
      max_findings_per_language:
        description: "Cap per language after filtering (0 = no cap; may run a long time)"
        required: true
        default: "100"

permissions:
  contents: write
  pull-requests: write
  actions: read
  security-events: write

concurrency:
  group: veracode-ultimate-${{ github.ref }}
  cancel-in-progress: false

jobs:
  pipeline_scan_and_sarif:
    runs-on: ubuntu-latest
    outputs:
      has_results: ${{ steps.scan_outputs.outputs.has_results }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure placeholder file exists (SARIF)
        run: |
          mkdir -p .veracode
          cat > .veracode/PIPELINE_SCAN_GLOBAL_FINDINGS.md << 'EOF'
          # Veracode Pipeline Scan – Global Findings Placeholder
          Findings without a resolvable repo file+line are anchored here.
          EOF

      - name: Create source zip (exclude node_modules / .git)
        run: |
          zip -r pipeline-src.zip . \
            -x "**/node_modules/**" \
            -x "**/.git/**" \
            -x "**/.veracode/**"

      - name: Set up Java (Pipeline Scan tool)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Download Pipeline Scan tool
        run: |
          curl -sSLO https://downloads.veracode.com/securityscan/pipeline-scan-LATEST.zip
          unzip -o pipeline-scan-LATEST.zip

      - name: Run Pipeline Scan (ESD enabled, do not fail job on findings)
        id: scan_outputs
        env:
          VERACODE_API_ID: ${{ secrets.VID }}
          VERACODE_API_KEY: ${{ secrets.VKEY }}
        run: |
          set -euo pipefail

          # Pipeline scan exits non-zero when findings exist; capture but don't fail.
          set +e
          java -jar pipeline-scan.jar \
            -vid "${VERACODE_API_ID}" \
            -vkey "${VERACODE_API_KEY}" \
            -f "pipeline-src.zip" \
            -esd true \
            -jf "results.json" \
            -fjf "filtered_results.json"
          RC=$?
          set -e

          echo "Pipeline Scan exit code: $RC"
          ls -lah results.json filtered_results.json || true

          if [ -f results.json ] && [ -f filtered_results.json ]; then
            echo "has_results=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_results=false" >> "$GITHUB_OUTPUT"
            echo "ERROR: Pipeline Scan did not produce results.json / filtered_results.json"
            exit 1
          fi

      - name: Setup Python (SARIF + telemetry)
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Convert Pipeline JSON -> SARIF
        run: |
          python scripts/pipeline_results_to_sarif.py \
            --input filtered_results.json \
            --output veracode-pipeline.sarif \
            --placeholder-uri .veracode/PIPELINE_SCAN_GLOBAL_FINDINGS.md \
            --output-stats veracode-pipeline-sarif-stats.json

      - name: Upload SARIF to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: veracode-pipeline.sarif
          category: veracode-pipeline
          wait-for-processing: true

      - name: Telemetry — summarize pipeline findings (overall + batch-fixable-by-language)
        run: |
          python - << 'PY'
          import json
          from collections import Counter

          ALLOW = {
            "java":       {"80","89","113","117","159","209","331","404","597","611"},
            "kotlin":     {"80","89","113","117","331","404"},
            "scala":      {"78","80","117","611"},
            "csharp":     {"80","89","117","209","316","331","352","404","611"},
            "javascript": {"80","89","113","117","209","352","601","611","614"},
            "python":     {"78","80","89","295","331","757"},
            "php":        {"80","89","117"},
            "go":         {"73","78","117"},
          }

          EXT_TO_LANG = {
            ".java":"java", ".jsp":"java",
            ".kt":"kotlin",
            ".scala":"scala",
            ".cs":"csharp",
            ".js":"javascript", ".ts":"javascript", ".jsx":"javascript", ".tsx":"javascript",
            ".py":"python",
            ".php":"php",
            ".go":"go",
          }

          def norm(p): return (p or "").replace("\\","/").strip()
          def src_path(f):
            src = ((f.get("files") or {}).get("source_file") or {})
            return norm(src.get("file") or src.get("upload_file") or "")

          data = json.load(open("filtered_results.json","r",encoding="utf-8"))
          findings = data.get("findings", []) if isinstance(data, dict) else []

          total = len(findings)
          sev = Counter()
          cwe = Counter()
          ext = Counter()
          batch_fixable_by_lang = Counter()

          for f in findings:
            if not isinstance(f, dict):
              continue
            sev[str(f.get("severity","UNKNOWN"))] += 1
            cid = str(f.get("cwe_id") or "").strip()
            if cid:
              cwe[cid] += 1

            p = src_path(f).lower()
            lang = None
            for e, l in EXT_TO_LANG.items():
              if p.endswith(e):
                lang = l
                ext[e] += 1
                break

            if lang and cid and cid in ALLOW.get(lang, set()):
              batch_fixable_by_lang[lang] += 1

          out = {
            "total_findings": total,
            "severity_counts": dict(sev),
            "top_cwes": dict(cwe.most_common(20)),
            "file_extension_counts": dict(ext),
            "batch_fixable_findings_by_language": dict(batch_fixable_by_lang),
          }

          with open("veracode_telemetry_pipeline.json","w",encoding="utf-8") as fp:
            json.dump(out, fp, indent=2)

          print(json.dumps(out, indent=2))
          PY

      - name: Upload pipeline artifacts + telemetry
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: veracode-pipeline-scan
          path: |
            results.json
            filtered_results.json
            veracode-pipeline.sarif
            veracode-pipeline-sarif-stats.json
            veracode_telemetry_pipeline.json
            .veracode/PIPELINE_SCAN_GLOBAL_FINDINGS.md

  build_fix_matrix:
    needs: pipeline_scan_and_sarif
    if: needs.pipeline_scan_and_sarif.outputs.has_results == 'true'
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.mk.outputs.matrix }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download scan outputs
        uses: actions/download-artifact@v4
        with:
          name: veracode-pipeline-scan
          path: pipeline_out

      - name: Setup Python (matrix builder)
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Build Fix matrix dynamically from findings (only batch-fixable)
        id: mk
        run: |
          python - << 'PY'
          import json, os
          from collections import Counter

          ALLOW = {
            "java":       {"80","89","113","117","159","209","331","404","597","611"},
            "kotlin":     {"80","89","113","117","331","404"},
            "scala":      {"78","80","117","611"},
            "csharp":     {"80","89","117","209","316","331","352","404","611"},
            "javascript": {"80","89","113","117","209","352","601","611","614"},
            "python":     {"78","80","89","295","331","757"},
            "php":        {"80","89","117"},
            "go":         {"73","78","117"},
          }

          EXT_TO_LANG = {
            ".java":"java", ".jsp":"java",
            ".kt":"kotlin",
            ".scala":"scala",
            ".cs":"csharp",
            ".js":"javascript", ".ts":"javascript", ".jsx":"javascript", ".tsx":"javascript",
            ".py":"python",
            ".php":"php",
            ".go":"go",
          }

          IGNORE_ROOTS = {"target","dist","build","out",".veracode",".github","node_modules"}

          def norm(p: str) -> str:
            return (p or "").replace("\\","/").strip()

          def src_path(f: dict) -> str:
            src = ((f.get("files") or {}).get("source_file") or {})
            return norm(src.get("file") or src.get("upload_file") or "")

          data = json.load(open("pipeline_out/filtered_results.json","r",encoding="utf-8"))
          findings = data.get("findings", []) if isinstance(data, dict) else []

          lang_fixable_counts = Counter()
          js_root_counts = Counter()

          for f in findings:
            if not isinstance(f, dict):
              continue
            p = src_path(f).lower()
            if not p or p == "unknown":
              continue

            lang = None
            for ext, l in EXT_TO_LANG.items():
              if p.endswith(ext):
                lang = l
                break
            if not lang:
              continue

            cid = str(f.get("cwe_id") or "").strip()
            if cid and cid in ALLOW.get(lang, set()):
              lang_fixable_counts[lang] += 1

            if lang == "javascript":
              parts = p.split("/")
              if parts and parts[0] and parts[0] not in IGNORE_ROOTS:
                js_root_counts[parts[0]] += 1

          def mk_map(frm: str, to: str) -> str:
            return f"{frm}:{to}"

          # Always provide 3 NON-EMPTY mappings (Fix action can misbehave on empty strings)
          # Java: handle both "src/main/java/..." and "com/..." and JSP WEB-INF.
          JAVA_SBP = (
            mk_map("src/main/java/", "src/main/java/"),     # identity
            mk_map("com/", "src/main/java/com/"),           # com -> src/main/java/com
            mk_map("WEB-INF", "src/main/webapp/WEB-INF"),   # WEB-INF -> src/main/webapp/WEB-INF
          )

          # JS: top 3 roots from findings; identity mappings; never empty.
          js_roots = [r for r,_ in js_root_counts.most_common(3)]
          if not js_roots:
            js_roots = ["src"]
          JS_SBP = [mk_map(f"{r}/", f"{r}/") for r in js_roots[:3]]
          while len(JS_SBP) < 3:
            JS_SBP.append(JS_SBP[0])
          JS_SBP = tuple(JS_SBP[:3])

          # Safe defaults (non-empty) for other languages
          DEFAULT_SBP = (mk_map("src/", "src/"), mk_map("src/", "src/"), mk_map("src/", "src/"))

          BASE = {
            "java": JAVA_SBP,
            "kotlin": (mk_map("src/main/kotlin/", "src/main/kotlin/"), mk_map("com/", "src/main/kotlin/com/"), mk_map("src/main/java/", "src/main/java/")),
            "scala":  (mk_map("src/main/scala/", "src/main/scala/"),   mk_map("com/", "src/main/scala/com/"),  mk_map("src/main/java/", "src/main/java/")),
            "csharp": DEFAULT_SBP,
            "javascript": JS_SBP,
            "python": (mk_map("src/", "src/"), mk_map("app/", "app/"), mk_map("src/", "src/")),
            "php": DEFAULT_SBP,
            "go": DEFAULT_SBP,
          }

          include = []
          for lang, count in lang_fixable_counts.items():
            if count <= 0:
              continue
            sbp1, sbp2, sbp3 = BASE[lang]
            cwe_list = ",".join(sorted(ALLOW[lang], key=lambda x: int(x)))
            include.append({"language": lang, "cwe": cwe_list, "sbp1": sbp1, "sbp2": sbp2, "sbp3": sbp3})

          include = sorted(include, key=lambda x: x["language"])
          matrix = {"include": include}

          matrix_str = json.dumps(matrix, separators=(",", ":"))
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as out:
            out.write(f"matrix={matrix_str}\n")

          telem = {
            "batch_fixable_counts_by_language": dict(lang_fixable_counts),
            "javascript_roots_from_findings_top3": js_roots[:3],
            "javascript_source_base_paths": list(BASE["javascript"]),
            "matrix_languages": [x["language"] for x in include],
          }
          json.dump(telem, open("veracode_telemetry_fix_matrix.json","w",encoding="utf-8"), indent=2)
          print(json.dumps(telem, indent=2))
          PY

      - name: Upload Fix-matrix telemetry
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: veracode-fix-matrix-telemetry
          path: veracode_telemetry_fix_matrix.json

  veracode_fix_universal:
    needs: [pipeline_scan_and_sarif, build_fix_matrix]
    if: >
      (github.event_name == 'pull_request' || inputs.run_fix == 'true')
      && needs.build_fix_matrix.outputs.matrix != ''
      && needs.build_fix_matrix.outputs.matrix != '{"include":[]}'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: ${{ fromJson(needs.build_fix_matrix.outputs.matrix) }}

    env:
      # Allow customer to choose at manual run time; sensible defaults for PR runs
      FIX_SEVERITIES: ${{ github.event_name == 'workflow_dispatch' && inputs.fix_severities || '5,4' }}
      MAX_FINDINGS_PER_LANGUAGE: ${{ github.event_name == 'workflow_dispatch' && inputs.max_findings_per_language || '100' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download scan outputs
        uses: actions/download-artifact@v4
        with:
          name: veracode-pipeline-scan
          path: pipeline_out

      - name: Setup Python (Fix input filtering + telemetry)
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Filter Fix input to language=${{ matrix.language }} + CWEs + selected severities + cap
        id: filter
        run: |
          set -euo pipefail
          python - << 'PY'
          import json, os

          lang = os.environ["LANG"]
          allow_cwes = set((os.environ.get("ALLOW_CWES") or "").split(",")) if os.environ.get("ALLOW_CWES") else set()
          sev_allow = set(s.strip() for s in (os.environ.get("FIX_SEVERITIES") or "").split(",") if s.strip() != "")
          cap = int(os.environ.get("MAX_FINDINGS_PER_LANGUAGE", "0") or "0")

          inp = "pipeline_out/filtered_results.json"
          outp = f"pipeline_out/filtered_results_{lang}.json"

          LANG_EXTS = {
            "java": [".java", ".jsp"],
            "kotlin": [".kt"],
            "scala": [".scala"],
            "csharp": [".cs"],
            "javascript": [".js", ".ts", ".jsx", ".tsx"],
            "python": [".py"],
            "php": [".php"],
            "go": [".go"],
          }
          exts = LANG_EXTS.get(lang, [])
          if not exts:
            raise SystemExit(f"No ext mapping for {lang}")

          def norm(p): return (p or "").replace("\\","/").strip()

          def src_path(f):
            src = ((f.get("files") or {}).get("source_file") or {})
            return norm(src.get("file") or src.get("upload_file") or "")

          def sev_int(f):
            try: return int(f.get("severity", 0) or 0)
            except Exception: return 0

          def sev_str(f):
            v = f.get("severity", None)
            return str(v) if v is not None else ""

          data = json.load(open(inp, "r", encoding="utf-8"))
          findings = data.get("findings", []) if isinstance(data, dict) else []

          kept = []
          for f in findings:
            if not isinstance(f, dict):
              continue
            p = src_path(f)
            if not p or p.lower() == "unknown":
              continue
            pl = p.lower()
            if not any(pl.endswith(e) for e in exts):
              continue

            cwe = str(f.get("cwe_id") or "").strip()
            if allow_cwes and cwe not in allow_cwes:
              continue

            s = sev_str(f).strip()
            if sev_allow and s not in sev_allow:
              continue

            kept.append(f)

          kept.sort(key=sev_int, reverse=True)

          if cap > 0 and len(kept) > cap:
            kept = kept[:cap]

          data2 = dict(data)
          data2["findings"] = kept
          json.dump(data2, open(outp, "w", encoding="utf-8"), indent=2)

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as g:
            g.write(f"count={len(kept)}\n")
            g.write(f"file={outp}\n")

          t = {
            "language": lang,
            "allowed_cwes": sorted(list(allow_cwes), key=lambda x: int(x)),
            "selected_severities": sorted(list(sev_allow)) if sev_allow else "ALL",
            "cap_per_language": cap,
            "findings_fed_to_fix": len(kept),
          }
          json.dump(t, open(f"veracode_telemetry_fix_input_{lang}.json","w",encoding="utf-8"), indent=2)

          print(f"Filtered for {lang}: {len(kept)} findings (severities={sorted(sev_allow) if sev_allow else 'ALL'}, cap={cap})")
          PY
        env:
          LANG: ${{ matrix.language }}
          ALLOW_CWES: ${{ matrix.cwe }}
          FIX_SEVERITIES: ${{ env.FIX_SEVERITIES }}
          MAX_FINDINGS_PER_LANGUAGE: ${{ env.MAX_FINDINGS_PER_LANGUAGE }}

      - name: Upload per-language Fix input telemetry
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: veracode-fix-input-telemetry-${{ matrix.language }}
          path: veracode_telemetry_fix_input_${{ matrix.language }}.json

      - name: Upload per-language filtered Fix input JSON
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: veracode-fix-input-json-${{ matrix.language }}
          path: ${{ steps.filter.outputs.file }}

      - name: Skip Fix when no findings match filters for this language
        if: steps.filter.outputs.count == '0'
        run: |
          echo "No findings after CWE+severity+cap for language=${{ matrix.language }}. Skipping Fix."

      - name: Run Veracode Fix (Batch → PR) — language=${{ matrix.language }}
        if: steps.filter.outputs.count != '0'
        continue-on-error: true
        uses: Veracode/veracode-fix@v1.0.4
        with:
          vid: ${{ secrets.VID }}
          vkey: ${{ secrets.VKEY }}
          inputFile: ${{ steps.filter.outputs.file }}
          language: ${{ matrix.language }}
          cwe: ${{ matrix.cwe }}
          fixType: batch
          files: all
          prComment: ${{ github.event_name == 'pull_request' }}
          createPR: true
          source_base_path_1: ${{ matrix.sbp1 }}
          source_base_path_2: ${{ matrix.sbp2 }}
          source_base_path_3: ${{ matrix.sbp3 }}
