name: Veracode Ultimate (Pipeline Scan + SARIF + Batch Fix)

on:
  workflow_dispatch:
    inputs:
      run_fix:
        description: "Run Veracode Fix (batch PR) after scan"
        required: true
        default: "true"
  pull_request:
    branches: [ main, master ]

permissions:
  contents: write
  pull-requests: write
  actions: read
  security-events: write

jobs:
  pipeline_scan_and_sarif:
    if: github.event_name != 'pull_request' || !startsWith(github.head_ref, 'veracode-single-fix-holder-')
    runs-on: ubuntu-latest
    outputs:
      has_results: ${{ steps.scan_outputs.outputs.has_results }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure placeholder file exists (SARIF)
        run: |
          mkdir -p .veracode
          cat > .veracode/PIPELINE_SCAN_GLOBAL_FINDINGS.md << 'EOF'
          # Veracode Pipeline Scan – Global Findings Placeholder
          Findings without a resolvable repo file+line are anchored here.
          EOF

      - name: Create source zip (exclude node_modules)
        run: |
          zip -r pipeline-src.zip . -x "**/node_modules/**" -x "**/.git/**"

      - name: Set up Java (Pipeline Scan tool)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Download Pipeline Scan tool
        run: |
          curl -sSLO https://downloads.veracode.com/securityscan/pipeline-scan-LATEST.zip
          unzip -o pipeline-scan-LATEST.zip

      - name: Run Pipeline Scan (ESD enabled, do not fail job on findings)
        id: scan_outputs
        env:
          VERACODE_API_ID: ${{ secrets.VERACODE_API_ID }}
          VERACODE_API_KEY: ${{ secrets.VERACODE_API_KEY }}
        run: |
          set -euo pipefail

          # Pipeline scan exits non-zero when findings exist; capture but don't fail.
          set +e
          java -jar pipeline-scan.jar \
            -vid "${VERACODE_API_ID}" \
            -vkey "${VERACODE_API_KEY}" \
            -f "pipeline-src.zip" \
            -esd true \
            -jf "results.json" \
            -fjf "filtered_results.json"
          RC=$?
          set -e

          echo "Pipeline Scan exit code: $RC"
          ls -lah results.json filtered_results.json || true

          if [ -f results.json ] && [ -f filtered_results.json ]; then
            echo "has_results=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_results=false" >> "$GITHUB_OUTPUT"
            echo "ERROR: Pipeline Scan did not produce results.json / filtered_results.json"
            exit 1
          fi

      - name: Setup Python (SARIF + telemetry)
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Convert Pipeline JSON -> SARIF
        run: |
          python scripts/pipeline_results_to_sarif.py \
            --input filtered_results.json \
            --output veracode-pipeline.sarif \
            --placeholder-uri .veracode/PIPELINE_SCAN_GLOBAL_FINDINGS.md \
            --output-stats veracode-pipeline-sarif-stats.json

      - name: Upload SARIF to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: veracode-pipeline.sarif
          category: veracode-pipeline
          wait-for-processing: true

      - name: Telemetry — summarize pipeline findings (baseline + batch-fixable-by-language)
        run: |
          python - << 'PY'
          import json
          from collections import Counter

          ALLOW = {
            "java":       {"80","89","113","117","159","209","331","404","597","611"},
            "kotlin":     {"80","89","113","117","331","404"},
            "scala":      {"78","80","117","611"},
            "csharp":     {"80","89","117","209","316","331","352","404","611"},
            "javascript": {"80","89","113","117","209","352","601","611","614"},
            "python":     {"78","80","89","295","331","757"},
            "php":        {"80","89","117"},
            "go":         {"73","78","117"},
          }

          EXT_TO_LANG = {
            ".java":"java", ".jsp":"java",
            ".kt":"kotlin",
            ".scala":"scala",
            ".cs":"csharp",
            ".js":"javascript", ".ts":"javascript", ".jsx":"javascript", ".tsx":"javascript",
            ".py":"python",
            ".php":"php",
            ".go":"go",
          }

          def norm(p): return (p or "").replace("\\","/").strip()

          def canonicalize_path(p: str) -> str:
            # UNIVERSAL normalization to prevent Fix double-prefix issues on JVM repos
            p = norm(p).lstrip("./").lstrip("/")
            if p.startswith("src/main/java/"):
              p = p[len("src/main/java/"):]
            if p.startswith("src/main/webapp/"):
              p = p[len("src/main/webapp/"):]
            return p

          def src_path(f):
            src = ((f.get("files") or {}).get("source_file") or {})
            raw = src.get("file") or src.get("upload_file") or ""
            return canonicalize_path(raw)

          data = json.load(open("filtered_results.json","r",encoding="utf-8"))
          findings = data.get("findings", []) if isinstance(data, dict) else []

          total = len(findings)
          sev = Counter()
          cwe = Counter()
          ext = Counter()
          batch_fixable_by_lang = Counter()

          for f in findings:
            if not isinstance(f, dict):
              continue
            sev[str(f.get("severity","UNKNOWN"))] += 1
            cid = str(f.get("cwe_id") or "").strip()
            if cid:
              cwe[cid] += 1

            p = src_path(f).lower()
            lang = None
            for e,l in EXT_TO_LANG.items():
              if p.endswith(e):
                lang = l
                ext[e] += 1
                break

            if lang and cid and cid in ALLOW.get(lang,set()):
              batch_fixable_by_lang[lang] += 1

          out = {
            "total_findings": total,
            "severity_counts": dict(sev),
            "top_cwes": dict(cwe.most_common(15)),
            "file_extension_counts": dict(ext),
            "batch_fixable_findings_by_language": dict(batch_fixable_by_lang),
          }

          with open("veracode_telemetry_pipeline.json","w",encoding="utf-8") as fp:
            json.dump(out, fp, indent=2)

          print(json.dumps(out, indent=2))
          PY

      - name: Upload pipeline artifacts + telemetry
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: veracode-pipeline-scan
          path: |
            results.json
            filtered_results.json
            veracode-pipeline.sarif
            veracode-pipeline-sarif-stats.json
            veracode_telemetry_pipeline.json
            .veracode/PIPELINE_SCAN_GLOBAL_FINDINGS.md

  build_fix_matrix:
    needs: pipeline_scan_and_sarif
    if: needs.pipeline_scan_and_sarif.outputs.has_results == 'true'
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.mk.outputs.matrix }}

    steps:
      - name: Download scan outputs
        uses: actions/download-artifact@v4
        with:
          name: veracode-pipeline-scan
          path: pipeline_out

      - name: Setup Python (matrix builder)
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Build Fix matrix dynamically from findings (only batch-fixable) + JS root hardening + JVM canonicalization
        id: mk
        run: |
          python - << 'PY'
          import json, os
          from collections import Counter

          ALLOW = {
            "java":       {"80","89","113","117","159","209","331","404","597","611"},
            "kotlin":     {"80","89","113","117","331","404"},
            "scala":      {"78","80","117","611"},
            "csharp":     {"80","89","117","209","316","331","352","404","611"},
            "javascript": {"80","89","113","117","209","352","601","611","614"},
            "python":     {"78","80","89","295","331","757"},
            "php":        {"80","89","117"},
            "go":         {"73","78","117"},
          }

          EXT_TO_LANG = {
            ".java":"java", ".jsp":"java",
            ".kt":"kotlin",
            ".scala":"scala",
            ".cs":"csharp",
            ".js":"javascript", ".ts":"javascript", ".jsx":"javascript", ".tsx":"javascript",
            ".py":"python",
            ".php":"php",
            ".go":"go",
          }

          IGNORE_ROOTS = {"target","dist","build","out",".veracode",".github","node_modules"}

          def norm(p: str) -> str:
            return (p or "").replace("\\","/").strip()

          def canonicalize_path(p: str) -> str:
            p = norm(p).lstrip("./").lstrip("/")
            # JVM normalization to avoid double-prefix rewrites
            if p.startswith("src/main/java/"):
              p = p[len("src/main/java/"):]
            if p.startswith("src/main/webapp/"):
              p = p[len("src/main/webapp/"):]
            return p

          def src_path(f: dict) -> str:
            src = ((f.get("files") or {}).get("source_file") or {})
            raw = src.get("file") or src.get("upload_file") or ""
            return canonicalize_path(raw)

          data = json.load(open("pipeline_out/filtered_results.json","r",encoding="utf-8"))
          findings = data.get("findings", []) if isinstance(data, dict) else []

          lang_fixable_counts = Counter()
          js_root_counts = Counter()

          for f in findings:
            if not isinstance(f, dict):
              continue
            p = src_path(f).lower()
            lang = None
            for ext, l in EXT_TO_LANG.items():
              if p.endswith(ext):
                lang = l
                break
            if not lang:
              continue

            cid = str(f.get("cwe_id") or "").strip()
            if cid and cid in ALLOW.get(lang, set()):
              lang_fixable_counts[lang] += 1

            if lang == "javascript":
              parts = p.split("/")
              if parts and parts[0] and parts[0] not in IGNORE_ROOTS:
                js_root_counts[parts[0]] += 1

          # JS/TS: derive top 3 roots from findings (no os.path.isdir)
          js_roots = [r for r,_ in js_root_counts.most_common(3)]
          if not js_roots:
            js_roots = ["src"]

          def mk_map(a: str, b: str) -> str:
            return f"{a}:{b}"

          def java_maps():
            # Use your proven mapping style
            return (
              mk_map("com/","src/main/java/com/"),
              mk_map("WEB-INF","src/main/webapp/WEB-INF"),
              mk_map("com/","src/main/java/com/"),
            )

          BASE = {
            "java":   java_maps(),
            "kotlin": (mk_map("com/","src/main/java/com/"), mk_map("com/","src/main/java/com/"), mk_map("com/","src/main/java/com/")),
            "scala":  (mk_map("com/","src/main/java/com/"), mk_map("com/","src/main/java/com/"), mk_map("com/","src/main/java/com/")),
            "csharp": (mk_map("src/","src/"), mk_map("src/","src/"), mk_map("src/","src/")),
            "python": (mk_map("src/","src/"), mk_map("app/","app/"), mk_map("src/","src/")),
            "php":    (mk_map("src/","src/"), mk_map("src/","src/"), mk_map("src/","src/")),
            "go":     (mk_map("src/","src/"), mk_map("src/","src/"), mk_map("src/","src/")),
          }

          # JS: top 3 roots; always supply 3 mappings (never empty)
          js_maps = [mk_map(f"{r}/", f"{r}/") for r in js_roots[:3]]
          while len(js_maps) < 3:
            js_maps.append(js_maps[0])
          BASE["javascript"] = tuple(js_maps[:3])

          include = []
          for lang, count in lang_fixable_counts.items():
            if count <= 0:
              continue
            sbp1, sbp2, sbp3 = BASE[lang]
            cwe_list = ",".join(sorted(ALLOW[lang], key=lambda x: int(x)))
            include.append({"language": lang, "cwe": cwe_list, "sbp1": sbp1, "sbp2": sbp2, "sbp3": sbp3})

          include = sorted(include, key=lambda x: x["language"])

          matrix = {"include": include}
          matrix_str = json.dumps(matrix, separators=(",", ":"))
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as out:
            out.write(f"matrix={matrix_str}\n")

          telem = {
            "batch_fixable_counts_by_language": dict(lang_fixable_counts),
            "javascript_roots_from_findings_top3": js_roots[:3],
            "javascript_source_base_paths": list(BASE["javascript"]),
            "matrix_languages": [x["language"] for x in include],
          }
          json.dump(telem, open("veracode_telemetry_fix_matrix.json","w",encoding="utf-8"), indent=2)
          print(json.dumps(telem, indent=2))
          PY

      - name: Upload Fix-matrix telemetry
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: veracode-fix-matrix-telemetry
          path: veracode_telemetry_fix_matrix.json

  veracode_fix_universal:
    needs: [pipeline_scan_and_sarif, build_fix_matrix]
    if: (github.event_name == 'pull_request' || inputs.run_fix == 'true') && needs.build_fix_matrix.outputs.matrix != '' && needs.build_fix_matrix.outputs.matrix != '{"include":[]}'
    runs-on: ubuntu-latest
    timeout-minutes: 120
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: ${{ fromJson(needs.build_fix_matrix.outputs.matrix) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download scan outputs
        uses: actions/download-artifact@v4
        with:
          name: veracode-pipeline-scan
          path: pipeline_out

      - name: Setup Python (Fix input filtering + telemetry)
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Filter Fix input to language=${{ matrix.language }} and allowed CWEs only (with JVM canonicalization + dedupe)
        id: filter
        run: |
          set -euo pipefail
          python - << 'PY'
          import json, os

          lang = os.environ["LANG"]
          allow = set(os.environ["ALLOW_CWES"].split(",")) if os.environ.get("ALLOW_CWES") else set()
          inp = "pipeline_out/filtered_results.json"
          outp = f"pipeline_out/filtered_results_{lang}.json"

          LANG_EXTS = {
            "java": [".java", ".jsp"],
            "kotlin": [".kt"],
            "scala": [".scala"],
            "csharp": [".cs"],
            "javascript": [".js", ".ts", ".jsx", ".tsx"],
            "python": [".py"],
            "php": [".php"],
            "go": [".go"],
          }

          exts = LANG_EXTS.get(lang, [])
          if not exts:
            raise SystemExit(f"No ext mapping for {lang}")

          def norm(p): return (p or "").replace("\\","/").strip()

          def canonicalize_path(p: str) -> str:
            # Prevent double-prefix issues for JVM repos
            p = norm(p).lstrip("./").lstrip("/")
            if p.startswith("src/main/java/"):
              p = p[len("src/main/java/"):]
            if p.startswith("src/main/webapp/"):
              p = p[len("src/main/webapp/"):]
            return p

          def src_path(f):
            src = ((f.get("files") or {}).get("source_file") or {})
            raw = src.get("file") or src.get("upload_file") or ""
            return canonicalize_path(raw)

          data = json.load(open(inp, "r", encoding="utf-8"))
          findings = data.get("findings", []) if isinstance(data, dict) else []

          kept = []
          for f in findings:
            if not isinstance(f, dict):
              continue
            p = src_path(f).lower()
            if not any(p.endswith(e) for e in exts):
              continue
            cwe = str(f.get("cwe_id") or "").strip()
            if allow and cwe not in allow:
              continue

            # write canonical path back so Fix sees only one style
            if "files" in f and "source_file" in (f.get("files") or {}):
              f["files"]["source_file"]["file"] = src_path(f)

            kept.append(f)

          # Dedupe: same (path,line,cwe) often appears twice in mixed repos
          seen = set()
          deduped = []
          for f in kept:
            p = src_path(f).lower()
            line = str(((f.get("files") or {}).get("source_file") or {}).get("line") or f.get("source_file_line") or "")
            cwe = str(f.get("cwe_id") or "").strip()
            key = (p, line, cwe)
            if key in seen:
              continue
            seen.add(key)
            deduped.append(f)
          kept = deduped

          data2 = dict(data)
          data2["findings"] = kept
          json.dump(data2, open(outp, "w", encoding="utf-8"), indent=2)

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as g:
            g.write(f"count={len(kept)}\n")
            g.write(f"file={outp}\n")

          t = {
            "language": lang,
            "allowed_cwes": sorted(list(allow), key=lambda x: int(x)),
            "batch_fixable_findings_in_input": len(kept),
          }
          json.dump(t, open(f"veracode_telemetry_fix_input_{lang}.json","w",encoding="utf-8"), indent=2)

          print(f"Filtered for {lang} (allowed CWEs only): {len(kept)}")
          PY
        env:
          LANG: ${{ matrix.language }}
          ALLOW_CWES: ${{ matrix.cwe }}

      - name: Upload per-language Fix input telemetry
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: veracode-fix-input-telemetry-${{ matrix.language }}
          path: veracode_telemetry_fix_input_${{ matrix.language }}.json

      - name: Upload per-language filtered Fix input JSON
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: veracode-fix-input-json-${{ matrix.language }}
          path: ${{ steps.filter.outputs.file }}

      - name: Skip Fix when no batch-fixable findings for this language
        if: steps.filter.outputs.count == '0'
        run: |
          echo "No batch-fixable findings for language=${{ matrix.language }}. Skipping Fix."

      - name: Run Veracode Fix (Batch → PR) — language=${{ matrix.language }}
        if: steps.filter.outputs.count != '0'
        continue-on-error: true
        uses: Veracode/veracode-fix@v1.0.4
        with:
          vid: ${{ secrets.VID }}
          vkey: ${{ secrets.VKEY }}
          inputFile: ${{ steps.filter.outputs.file }}
          language: ${{ matrix.language }}
          cwe: ${{ matrix.cwe }}
          fixType: batch
          files: all
          prComment: true
          createPR: true
          source_base_path_1: ${{ matrix.sbp1 }}
          source_base_path_2: ${{ matrix.sbp2 }}
          source_base_path_3: ${{ matrix.sbp3 }}
